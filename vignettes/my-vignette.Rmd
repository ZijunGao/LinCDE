---
title: "LinCDE"
author: Zijun Gao
date: May 2021
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{LinCDE vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


<!-- Conditional density estimation is a fundamental problem in statistics, with various scientific and practical applications such as genetics and economics. We propose a conditional density estimator based on tree boosting and Lindsey's method (LinCDE). LinCDE admits flexible modeling of the density family and captures distributional characteristics like modality and shape. In particular, LinCDE always produces smooth and non-negative density estimates. Furthermore, in the presence of nuisances, LinCDE identifies the influential covariates to the response distribution.  -->

In this vignette, we will introduce how to use the R package LinCDE for conditional density estimation.

## Background

The density of a continuous random variable characterizes its relative likelihood of taking a specific value. In statistics, many questions are essentially questions of density characteristics, e.g., location, variance, modality, and skewness. A fruitful collection of methods have been proposed for density estimation, such as kernel density estimation, Lindsey's method.

In practice, the density of interest is often heterogeneous across observations. For instance, the density of height goes up in the mean from children to adults, the density of food expenditure is more variant among the higher-income community relative to the lower-income community, and the density of salary is bi-modal among lawyers while unimodal among firefighters. The heterogeneity in conditional densities often conveys meaningful messages. 

We propose LinCDE to estimate the conditional densities. LinCDE is a boosting algorithm based on LinCDE trees. A LinCDE tree partitions the covariate space into subregions with approximately locally homogeneous densities, employs Lindsey's method for density estimation in the subregions, and aggregates the densities from different sub-areas as the estimated conditional density. LinCDE grows a number of LinCDE trees in a stagewise forward manner, and each tree fits the residuals of the previous estimate. For more details, please refer to the LinCDE paper.


## LinCDE package
### A toy example
We illustrate the workflow of the LinCDE package using a toy example.

Before all, install and attach the LinCDE package. 
```{r setup}
library("LinCDE")
```

Next, we prepare the example dataset. The function requires a covariate matrix and a response vector. In this example, we generate $20$ covariates uniformly from $[-1,1]$. Given a covariate value, the response is locally Gaussian. The response depends on the covariates through its mean and variance. In particular, $X_1$ and $X_2$ influence the response's mean, and $X_2$ also influences the response's variance. The lattice plot below visualizes the conditional densities at $9$ different covariate values. We conduct conditional density estimation based on $1000$ independent samples.

```{r}
# training data
set.seed(100)
n = 1000; d = 20
X = matrix(runif(n * d, -1, 1), ncol = d)
y = 0.5 * X[,1] + X[,1] * X[,2] + rnorm(n,0,1) * (0.5 + 0.25 * X[,2])
```

```{r,fig.height=5.3, fig.width = 7, fig.align="center"}
# conditional density plot
XProfile = matrix(runif(3^2 * d,-1,1), nrow = 3^2, ncol = d)
XProfile[,1] = rep(c(-0.6,0,0.6), 3)
XProfile[,2] = rep(c(0.6,0,-0.6), rep(3,3))

exampleDensity = function(X, y){
  if(is.null(dim(X))){X = matrix(X, nrow = 1)}
  result = dnorm(y, mean = (0.5 * X[,1] + X[,1] * X[,2]), sd = (0.5 + 0.25 * X[,2]))
  return(result)
}

densityPlot(X = XProfile, minY = min(y), maxY = max(y), trueDensity = exampleDensity)
```

#### Fitting

To run LinCDE, we need to determine a few hyper-parameters critical to the performance. The two primary parameters of interest are the number of iterations (_n.trees_) and the depths of LinCDE trees (_depth_).

  * _n.trees_: the number of LinCDE trees to fit. We train a LinCDE model on the training data with a large number of trees, e.g., 100 trees. We then compute the validation log-likelihoods after each iteration on a separate validation dataset. We choose the number of iterations with the maximal validation log-likelihood. 

    In the following example with _depth = 2_, we specify the maximal number of trees as $100$. We evaluate the validation log-likelihood and plot the curve. The log-likelihood first increases then stabilizes at $-0.76$ after $50$ iterations. Therefore, we choose _n.trees = 50_ for _depth = 2_.

  * _depth_: the number of splits of each LinCDE tree. We apply LinCDE with a grid of depths. For each depth, we choose the number of iterations as above and record the associated validation log-likelihood. We choose the depth with the maximal validation log-likelihood. 
  
    In the following example, we experiment with _depth = 1_ and _depth = 2_. For _depth = 1_, we choose _100_ iterations, and the associated log-likelihood is $-0.80$. For _depth = 2_, we choose _50_ iterations, and the associated log-likelihood is $-0.76$. Since $-0.76 > -0.80$, we choose _depth = 2_. Notice that the example's conditional mean involves an interaction term of $X_1$ and $X_2$, and thus _depth = 1_ --- an additive model in the density's exponent --- is less efficient than _depth = 2_ --- a richer model including first-order interactions.
    
    In standard boosting, deep trees are problematic due to overfitting. In LinCDE, the overfitting issue is more severe because the density estimation problem at terminal nodes is more complicated than regression and classification. As a result, we do not recommend _depth > 5_.


```{r, fig.height=4.5, fig.width = 6, fig.align="center", cache=TRUE}
# validation data
set.seed(318)
nVal = 1000; d = 20
XVal = matrix(runif(nVal * d, -1, 1), ncol = d)
yVal = 0.5 * XVal[,1] + XVal[,1] * XVal[,2] + rnorm(nVal,0,1) * (0.5 + 0.25 * XVal[,2])

exampleD1 = LinCDEBoosting(y = y, X = X, depth = 1, n.trees = 100)
predictExampleD1 = LinCDEPredict(X = XVal, y = yVal, trees = exampleD1)
plot(predictExampleD1$testLogLikelihoodHistory, pch = 16, main = "depth = 1", xlab = "iteration", ylab = "log-likeihood")

exampleD2 = LinCDEBoosting(y = y, X = X, depth = 2, n.trees = 100)
predictExampleD2 = LinCDEPredict(X = XVal, y = yVal, trees = exampleD2)
plot(predictExampleD2$testLogLikelihoodHistory, pch = 16, main = "depth = 2", xlab = "iteration", ylab = "log-likeihood")
```
There are a number of secondary hyper-parameters. We recommend starting with the default values and making changes only if certain issues are observed.

  * _z_: the type of spline basis. Default is the cubic natural spline basis. Cubic natural splines are desirable for their flexibility, smoothness, and linear extensions beyond the boundaries. However, if the conditional densities are believed to belong to a certain distribution family, then specific _z_ should be adopted. Here are two examples. 
    + In the above example where the response is locally Gaussian, _z = "Gaussian"_ is the most appropriate choice.
    + For the modality and skewness examples below, the response can be locally bi-modal. _z = "Gaussian"_ can not produce bi-modality structures and a more flexible spline basis should be adopted.
    
  * _splineDf_: the number of spline basis. Default is $10$. If you go with the natural cubic spline basis, then _splineDf_ specifies the splines' degrees of freedom, i.e., the number of spline bases. A larger _splineDf_ is able to characterize more local structures but may produce unnecessary curvatures. 

  * _df_: the ridge Poisson regression's degrees of freedom. Default is $2$. _df_ is used for determining the ridge regularization hyper-parameter. A smaller _df_ corresponds to a larger regularization parameter, and assists to avoid computational instabilities at subregions with a limited number of observations. 

  * _prior_: type of the initial carrying density. Default is "Gaussian", i.e., the Gaussian distribution with the marginal response mean and the standard deviation is used as the universal density initialization. If you set _prior = "uniform"_, the uniform distribution over the response range is used. If you set _prior = "LindseyMarginal"_, the marginal response density estimated by Lindsey's method based on all responses is used. You can also input a homogeneous or heterogeneous conditional density function. The conditional density function should take a covariate matrix $X$, a response vector $y$, and output the densities at pairs $(X, y)$. If the prior conditional density is close to the underlying truth, e.g., a pretrained conditional density estimator, LinCDE will require less iterations. 
  
  In below, the prior distribution is similar to the true conditional density. It takes LinCDE about $15$ iterations to converge, much faster compared to the $50$ iterations with the Gaussian prior.
  
```{r, fig.height=4.5, fig.width = 6, fig.align="center", cache = TRUE}
# input a heterogeneous conditional density function as prior
priorDensity = function(X, y){
  if(is.null(dim(X))){X = matrix(X, nrow = 1)}
  result = dnorm(y, mean = 0.3 * X[,1] + X[,1] * X[,2] , sd = (0.5 + 0.25 * X[,2]))
  return(result)
}

examplePrior = LinCDEBoosting(y = y, X = X, z = "Gaussian", depth = 2, n.trees = 50, shrinkage = 0.1, prior = priorDensity)
predictExamplePrior = LinCDEPredict(X = XVal, y = yVal, trees = examplePrior)
plot(predictExamplePrior$testLogLikelihoodHistory, pch = 16, main = "depth = 2", xlab = "iteration", ylab = "log-likeihood")
```
  
  * Standard boosting parameters:  
    + _splitPoint_: a list of candidate splits. Each element is a vector corresponding to a variable's candidate splits (including the left and right end points). The list's elements are ordered the same as $X$'s columns. An alternative input is candidate split numbers, a scalar if all variables share the same number of candidate splits, a vector of length nvars if variables have different numbers of candidate splits. If candidate split numbers are given, each variable's range is divided into _splitPoint-1_ intervals, i.e., _splitPoint_ knots, containing approximately the same number of observations. Default is $20$. Note that if a variable has fewer unique values than the desired number of intervals, split intervals corresponding to each unique value are created. 
    <!-- In this case, if there are less than _terminalSize_ observations at a unique value, the corresponding split interval will be merged to one of its neighbors. -->
  
    + _shrinkage_: the shrinkage parameter applied to each tree in the expansion, value in $(0,1]$. Default is $0.1$. A smaller _shrinkage_ leads to less overfitting but slower convergence.
  
    + _terminalSize_: the minimum number of observations in a terminal node. Default is $20$. We do not recommend a very small _terminalSize_, since the density model fit at each terminal node may involve quite a few parameters and a reasonable number of samples are needed.
    
  * Mean augmentation parameters:
    + _augmentation_: If true, a conditional mean model is fitted first, and LinCDE boosting is applied to the residuals. The augmentation is recommended for responses whose conditional support varies wildly. See below for an example. Default is false.
    + _augmentationMethod_: conditional mean estimator. If _augmentationMethod = "linearRegression"_, a regression model is fitted to the response. If _augmentationMethod = "randomForest"_, a random forest model is fitted. Default is fitting a random forest. Applies only to _augmentation = TRUE_.

In the above example, we set hyperparameters _splineDf = "Gaussian"_, _shrinkage = 0.02_, _depth = 3_, _n.trees = 300_, and leave other parameters at defualt values. 

```{r, cache=TRUE}
example = LinCDEBoosting(y = y, X = X, z = "Gaussian", depth = 3, n.trees = 300, shrinkage = 0.02)
```

#### Prediction

With a LinCDE model, we can predict conditional densities of an independent test dataset via function _predictLinCDE_ and evaluate LinCDE' performance. In the paper, we recommend the assessment metric: the relative improvement in the test log-likelihood
\begin{align*}
  \frac{\ell_{\text{LinCDE}} - \ell_{\text{null}}}{\ell_{\text{oracle}} - \ell_{\text{null}}},
\end{align*}
where the null model is the universal Gaussian distribution with the response's marginal mean and standard deviation, and the oracle denotes the true underlying conditional density. The criterion is analogous to the goodness-of-fit measure $R^2$ of linear regression. In this example, LinCDE achieves $83\%$ of the oracle's improvement over the null model.

```{r, cache=TRUE}
# test data
set.seed(813)
nTest = 1000; d = 20
XTest = matrix(runif(nTest * d, -1, 1), ncol = d)
yTest = 0.5 * XTest[,1] + XTest[,1] * XTest[,2] + rnorm(nTest,0,1) * (0.5 + 0.25 * XTest[,2])

# LinCDE
predictExample = LinCDEPredict(X = XTest, y = yTest, trees = example)
# null model
exampleNull = LinCDEBoosting(y = y, X = X, z = "Gaussian", n.trees = 0)
predictExampleNull = LinCDEPredict(X = XTest, y = yTest, trees = exampleNull)
# oracle
oracle = mean(log(exampleDensity(X = XTest, y = yTest)))
# relative improvement 
(relativeImprovement = (predictExample$testLogLikelihood - predictExampleNull$testLogLikelihood)/(oracle - predictExampleNull$testLogLikelihood)) 
```

When the true density is unknown, the relative improvement can't be computed. However, we can still obtain and use the absolute test log-likelihood as an assessment of LinCDE's performance. Besides, the visualization tools below help evaluate LinCDE.

#### Visualization

For visualization, we plot the estimated conditional densities against the truth at the above $9$ landmarks. The estimated conditional densities are very close to the truth.

```{r,fig.height=5.3, fig.width = 7, fig.align="center"}
# conditional density plot
XProfile = matrix(runif(3^2 * d,-1,1), nrow = 3^2, ncol = d)
XProfile[,1] = rep(c(-0.6,0,0.6), 3)
XProfile[,2] = rep(c(0.6,0,-0.6), rep(3,3))

densityPlot(X = XProfile, trueDensity = exampleDensity, trees = example)
```

To identify the influential covariates, we plot the importance scores for each covariate. The importance score barplot indicates that the first two candidates contribute the most to the improvement in the objective, which agrees with the underlying density model.

```{r, fig.height=4.5, fig.width = 6, fig.align="center"}
# importance score plot
barplot(example$importanceScore, names= paste("X", seq(1,d), sep = ""), main = "importance score", ylab = "importance", xlab = "covariates", cex.lab = 1, cex.main = 1)
```

### More examples
The above example shows LinCDE's ability to capture location and scale changes. We add two more examples focusing on modality and skewness, respectively.

For modality, we generate locally Gaussian mixture responses if $X_2 \le 0.2$, and locally Gaussian responses if $X_2 > 0.2$. Meanwhile, we let the responses' locations depend on the first covariate.

We follow the aforementioned workflow and set the hyper-parameters at _shrinkage = 0.02_, _depth = 3_, _n.trees = 200_ (the rest parameters are at default values). 

```{r, cache=TRUE}
# data generation parameters
set.seed(100)
n = 1000; d = 20
X = matrix(runif(n * d, -1, 1), ncol = d)
groupIndex = rbinom(n, 1, 0.5)
y = groupIndex * rnorm(n, -0.8, 0.3) + (1-groupIndex) * rnorm(n, 0.8, 0.3)
y = 0.25 * X[,1] + (X[,2] <= 0.2) * y + (X[,2] > 0.2) * rnorm(n, 0, 0.8)

exampleModality = LinCDEBoosting(y = y, X = X, depth = 3, n.trees = 200, shrinkage = 0.02)
```

We compare the estimated conditional densities against the truth at $9$ landmarks. The estimated conditional densities are clearly bi-modal for $X_2 = -0.5$ or $X_2 = 0$. For $X_2 = 0.5$, the estimated conditional densities are largely Gaussian with mild curvatures in the middle. The important covariates $X_1$ and $X_2$ are correctly identified.

<!-- When a shallow tree is grown, the terminal nodes may consist of heterogeneous samples, and the fitted densities will be a mixture of the Gaussian mixture and Gaussian. -->

```{r,fig.height=5.3, fig.width = 7, fig.align="center"}
# conditional density plot
XProfile = matrix(runif(3^2 * d,-1,1), nrow = 3^2, ncol = d)
XProfile[1:(3^2-1),1] = rep(c(-0.5,0.5), 4)
XProfile[1:(3^2-1),2] = rep(rep(c(-0.5,0.5), rep(2,2)),2)
XProfile[1:(3^2-1),3] = rep(c(-0.5,0.5), c(4,4))
XProfile[3^2,1:3] = rep(0,3)

exampleModalityDensity = function(X, y){
  if(is.null(dim(X))){X = matrix(X, nrow = 1)}
  result = rep(0, length(y))
  index = which(X[,2] < 0.2)
  result[index] = (0.5 * dnorm(y[index], mean = 0.25 * X[index,1] + 0.8, sd = 0.3) + 0.5 * dnorm(y[index], mean = 0.25 * X[index,1] - 0.8, sd = 0.3))
  result[-index] = dnorm(y[-index], mean = 0.25 * X[-index,1], sd = 0.8)
  return(result)
}

densityPlot(X = XProfile, trueDensity = exampleModalityDensity, trees = exampleModality)
```


```{r, fig.height=4.5, fig.width = 6, fig.align="center"}
# importance score plot
barplot(exampleModality$importanceScore, names= paste("X", seq(1,d), sep = ""), main = "importance score", ylab = "importance", xlab = "covariates", cex.lab = 1, cex.main = 1)
```

For skewness, we generate asymmetric Gaussian mixture responses. If $X_3 > 0$, the distribution is locally right-skewed; if $X_3 < 0$, the distribution is locally left-skewed. The larger the $|X_3|$ is, the more skewed the conditional distribution is. Meanwhile, we let the responses' locations depend on the first covariate.

We follow the aforementioned workflow and set the hyper-parameters at _shrinkage = 0.02_, _depth = 3_, _n.trees = 200_ (the rest parameters are at default values). 

We compare the estimated conditional densities against the truth at $9$ landmarks. The estimated conditional densities are right-skewed for $X_3 = 0.5$, left-skewed for $X_3 = -0.5$, and symmetric for $X_3 = 0$. The important covariates $X_1$ and $X_3$ are correctly identified

```{r, cache=TRUE}
# data generation parameters
n = 1000; d = 20
X = matrix(runif(n * d, -1, 1), ncol = d)
groupIndex = rbinom(n, 1, 0.5)
y = groupIndex * rnorm(n, 0.8, 0.5+0.45*X[,3]) + (1-groupIndex) * rnorm(n, -0.8, 0.5-0.45*X[,3]) + 0.25 * X[,1]

exampleSkewness = LinCDEBoosting(y = y, X = X, depth = 3, n.trees = 200, shrinkage = 0.02)
```

```{r,fig.height=5.3, fig.width = 7, fig.align="center"}
# conditional density plot
XProfile = matrix(runif(3^2 * d,-1,1), nrow = 3^2, ncol = d)
XProfile[1:(3^2-1),1] = rep(c(-0.5,0.5), 4)
XProfile[1:(3^2-1),2] = rep(rep(c(-0.5,0.5), rep(2,2)),2)
XProfile[1:(3^2-1),3] = rep(c(-0.5,0.5), c(4,4))
XProfile[3^2,1:3] = rep(0,3)

exampleSkewnessDensity = function(X, y){
  if(is.null(dim(X))){X = matrix(X, nrow = 1)}
  result = 0.5 * dnorm(y, mean = 0.25 * X[,1] + 0.8, sd = 0.5 + 0.45 * X[,3]) + 0.5 * dnorm(y, mean = 0.25 * X[,1] - 0.8, sd = 0.5 - 0.45 * X[,3])
  return(result)
}

densityPlot(X = XProfile, trueDensity = exampleSkewnessDensity, trees = exampleSkewness)
```

```{r, fig.height=4.5, fig.width = 6, fig.align="center"}
# importance score plot
barplot(exampleSkewness$importanceScore, names= paste("X", seq(1,d), sep = ""), main = "importance score", ylab = "importance", xlab = "covariates", cex.lab = 1, cex.main = 1)
```

### Mean augmentation

If a distribution's conditional components differ violently in location, then the response discretization in Lindsey's method could be problematic. In any local area, only a few bins are effective and the rest see no observations. Such grouping is coarse and there are no sufficient degrees of freedom to capture the distributional properties. We call this the "disjoint support" problem.

We propose to solve the "disjoint support" problem by mean augmentation. In particular, we suggest aligning the centers of the conditional densities in advance by estimating the conditional means first and subtracting the estimates from the responses. The residuals' supports are less heterogeneous, and we apply LinCDE boosting to the residuals to capture additional distributional structures. 

In the following example, we generate locally Gaussian mixture responses if $X_2 \le 0.2$, and locally Gaussian responses if $X_2 > 0.2$. Meanwhile, we let the responses' supports differ dramatically as $X_1$ changes, and thus the "disjoint support" problem is present.

We follow the aforementioned workflow and set the hyper-parameters at _shrinkage = 0.02_, _depth = 3_, _n.trees = 200_ (the rest parameters are at default values). We compare LinCDE boosting with and without mean augmentation. For mean augmentation, we use linear regression to estimate the conditional mean.

We compute the estimated conditional densities against the truth at $9$ landmarks. Without mean augmentation, LinCDE boosting identifies the location shift but the predicted conditional densities are unimodal everywhere. With mean augmentation, LinCDE boosting manages to produce the bi-modal structure for $X_2 \le 0.2$.

```{r, cache=TRUE}
# data generation parameters
set.seed(100)
n = 1000; d = 20
X = matrix(runif(n * d, -1, 1), ncol = d)
groupIndex = rbinom(n, 1, 0.5)
y = groupIndex * rnorm(n, -0.8, 0.3) + (1-groupIndex) * rnorm(n, 0.8, 0.3)
y = 4 * X[,1] + (X[,2] <= 0.2) * y + (X[,2] > 0.2) * rnorm(n, 0, 0.8)

# without mean augmentation
exampleAugmentation = LinCDEBoosting(y = y, X = X, depth = 3, n.trees = 200, shrinkage = 0.02)
# with mean augmentation
exampleAugmentationOLS = LinCDEBoosting(y = y, X = X, depth = 3, n.trees = 200, shrinkage = 0.02, augmentation = TRUE, augmentationMethod = "linearRegression")
```


```{r,fig.height=5.3, fig.width = 7, fig.align="center"}
# conditional density plot
XProfile = matrix(runif(3^2 * d,-1,1), nrow = 3^2, ncol = d)
XProfile[1:(3^2-1),1] = rep(c(-0.5,0.5), 4)
XProfile[1:(3^2-1),2] = rep(rep(c(-0.5,0.5), rep(2,2)),2)
XProfile[1:(3^2-1),3] = rep(c(-0.5,0.5), c(4,4))
XProfile[3^2,1:3] = rep(0,3)

exampleAugmentationDensity = function(X, y){
  if(is.null(dim(X))){X = matrix(X, nrow = 1)}
  result = rep(0, length(y))
  index = which(X[,2] < 0.2)
  result[index] = (0.5 * dnorm(y[index], mean = 4 * X[index,1] + 0.8, sd = 0.3) + 0.5 * dnorm(y[index], mean = 4 * X[index,1] - 0.8, sd = 0.3))
  result[-index] = dnorm(y[-index], mean = 4 * X[-index,1], sd = 0.8)
  return(result)
}

# without mean augmentation
densityPlot(X = XProfile, trueDensity = exampleAugmentationDensity, trees = exampleAugmentation)
```

```{r,fig.height=5.3, fig.width = 7, fig.align="center"}
# with mean augmentation
yMeanOLS = cbind(1,XProfile) %*% exampleAugmentationOLS$augmentationModel$coefficients
densityPlot(X = XProfile, trueDensity = exampleAugmentationDensity, trees = exampleAugmentationOLS, yMean = yMeanOLS)
```

## Plug in your own data and have fun with LinCDE!


<!-- # References -->



# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' LinCDECdf
#'
#' This function computes the cdf. for a LinCDE boosting model in C++.
#'
#' @param cellProb matrix of cell probabilities, of dimension nobs x number of bins.
#' @param y values to compute cdf. at (length nobs).
#' @param splitPointY split points of responses (length number of bins + 1).
#'
#' @return This function return a vector of cdf. (length nobs).
#'
LinCDECdf <- function(cellProb, y, splitPointY) {
    .Call('_LinCDE_LinCDECdf', PACKAGE = 'LinCDE', cellProb, y, splitPointY)
}

#' LinCDEQuantiles
#'
#' This function computes the quantiles for a LinCDE boosting model in C++.
#'
#' @param cellProb matrix of cell probabilities, of dimension nobs x number of bins.
#' @param probs levels of quantiles.
#' @param splitPointY split points of responses (length number of bins + 1).
#'
#' @return This function return a matrix of quantiles (dimension nobs x  number of quantile levels).
#'
LinCDEQuantiles <- function(cellProb, probs, splitPointY) {
    .Call('_LinCDE_LinCDEQuantiles', PACKAGE = 'LinCDE', cellProb, probs, splitPointY)
}

#' LinCDESplit
#'
#' This function computes the approximately optimal split in C++. A split is invalid if the sample size on the left or right of the split falls below 10
#'
#' @param X input matrix, of dimension nobs x nvars; each row represents an observation vector.
#' @param yIndex discretized response vector, of length nobs.
#' @param cellProb cell probability matrix, of dimension nobs x \code{numberBin}.
#' @param z sufficient statistics matrix, of dimension \code{numberBin} x number of sufficient statistics.
#' @param covMatrixInv inverse of psi'' (number of sufficient statistics x number of sufficient statistics).
#' @param splitPoint a candidate split list (length nvars). Each element is a vector corresponding to a certain variable's candidate splits (including the left and right end points).
#' @param numberBin the number of bins for response discretization.
#'
#' @return The function returns \code{splitVar}: the index of the variable to split at; \code{splitVal}: the cut-point of the split; \code{improvement}: the contribution of the split to the objective.
#'
LinCDESplit <- function(X, yIndex, cellProb, z, covMatrixInv, splitPoint, numberBin) {
    .Call('_LinCDE_LinCDESplit', PACKAGE = 'LinCDE', X, yIndex, cellProb, z, covMatrixInv, splitPoint, numberBin)
}

